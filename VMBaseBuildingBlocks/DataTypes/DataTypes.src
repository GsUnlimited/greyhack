import_code("../LowLevelNumberSwitch/LowLevelNumberSwitch.src":"../LowLevelNumberSwitch/LowLevelNumberSwitch.src")
import_code("../../checkers/checkers.src":"../../checkers/checkers.src")
import_code("../Mathlib/Mathlib.src":"../Mathlib/Mathlib.src")
BaseNumericDataType = {}
BaseNumericDataType.className = "BaseNumericDataType"
BaseNumericDataType.construct = function()
    self.decRules = {"NegativeAllowed":0,"Lowest":0,"Highest":0}
    self.hexRules={"WithZeroX":0,"Size":0}
    self.binaryRules={"Bytessize":0}
    self._decVal = 0
    self._hexVal = ""
    self._binaryVal = []
    return self
end function
BaseNumericDataType.configureRules = function(negativeAllowed,bytessize,withZeroX)
    typeCheckEqual(negativeAllowed,"number",@exit,self.className+".configureRules: negativeAllowed has to be of type number. Provided was: "+typeof(negativeAllowed)+"")
    typeCheckEqual(bytessize,"number",@exit,self.className+".configureRules: bytessize has to be of type number. Provided was: "+typeof(bytessize)+"")
    typeCheckEqual(withZeroX,"number",@exit,self.className+".configureRules: withZeroX has to be of type number. Provided was: "+typeof(withZeroX)+"")
    if negativeAllowed < 0 or negativeAllowed > 1 then
        exit(self.className+".configureRules: negativeAllowed has to be either 0(false) or 1 (true). Provided was:"+negativeAllowed+"")
    end if
    if withZeroX < 0 or withZeroX > 1 then
        exit(self.className+".configureRules: withZeroX has to be either 0(false) or 1 (true). Provided was: "+withZeroX+"")
    end if
    if bytessize < 0 then
        exit(self.className+".configureRules : bytessize has to be greater than 0. Provided was: "+bytessize+"")
    end if
    if bytessize > 8 then
        exit(self.className+".configureRules : bytessize has to be smaller than 8. There are no bigger possible DataTypes. Provided was: "+bytessize+"")
    end if
    self.decRules["NegativeAllowed"] = negativeAllowed
    self.binaryRules["Bytessize"] = bytessize
    self.hexRules["WithZeroX"] = withZeroX
    self._calculateRules()
end function

BaseNumericDataType._calculateRules = function()
    self.hexRules.Size = self.binaryRules.Bytessize * 2
    if self.decRules["NegativeAllowed"] == 0 then
        self.decRules["Highest"] = pow(2,self.binaryRules.Bytessize*8) -1
        self.decRules["Lowest"] = 0
        return
    else if self.decRules["NegativeAllowed"] == 1 then
        self.decRules.Highest = pow(2,self.binaryRules["Bytessize"]*8-1) 
        self.decRules.Lowest = pow(2,self.binaryRules["Bytessize"]*8) * -1
        return
    end if
        exit(self.className+"._calculateRules: self.decRules.NegativeAllowed has to be either 0(false) or 1 (true). Provided was: "+self.decRules["NegativeAllowed"]+"")
end function
BaseNumericDataType._validateDecVal = function(decVal)
    typeCheckEqual(decVal,"number",@exit,self.className+".setDecVal : decVal has to be of type number. Provided was :"+typeof(decVal)+".")
    if self.decRules["NegativeAllowed"] == 0 then
        self._checkNegativeDec(decVal)
        self._checkLowest(decVal)
        self._checkHighest(decVal)
    else if self.decRules["NegativeAllowed"] == 1 then
        self._checkLowest(decVal)
        self._checkHighest(decVal)
    else
        exit(self.className+".setDecVal : "+self.className+".decRules.NegativeAllowed has to be 0 or 1. Provided was :"+self.decRules.NegativeAllowed+".")
    end if
end function

BaseNumericDataType._checkNegativeDec = function(decVal)
    if decVal < 0 then
        exit(self.className+".checkNegativeDec: decVal has to be a postive. Provided was a value of: "+decVal+"")
    end if
end function

BaseNumericDataType._checkLowest = function(decVal)
    if decVal < self.decRules["Lowest"] then
        exit(self.className+".checkLowest: decVal has to be a minimum of "+self.decRules["Lowest"]+". Provided was a value of: "+decVal+"")
    end if
end function
BaseNumericDataType._checkHighest = function(decVal)
    if decVal > self.decRules["Highest"] then
        exit(self.className+".checkHighest: decVal has to a maximum of "+self.decRules["Highest"]+". Provided was a value of: "+decVal+"")
    end if
end function

BaseNumericDataType._validateBinaryVal = function(binaryVal)
    typeCheckEqual(binaryVal,"list",@exit,self.className+".validateBinaryVal: binaryVal has to be of type list. Provided was: "+typeof(binaryVal)+"")
    self._checkSize(binaryVal.len,self.binaryRules["Bytessize"],self.className+".validateBinaryVal: binaryVal has to have a lenght of"+self.binaryRules["Bytessize"]+". Provided was:"+binaryVal.len+"")
    for i in range(0,self.binaryRules["Bytessize"]-1)
        if binaryVal[i].len != 8 then
            exit(self.className+".validateBinaryVal: binaryVal["+i+"] has to be 8 characters long. Provided was "+binaryVal[i].len+"")
        end if
    end for
end function

BaseNumericDataType._validateHexVal = function(hexVal)
    typeCheckEqual(hexVal,"string",@exit,self.className+"._validateHexVal: hexVal has to be of type string. Provided was:"+typeof(hexVal)+"")
    sizeBaseErrorMessage = self.className+"._validateHexVal: hexVal.len has to be equal to "+self.hexRules["Size"]+". Provided was: "
    if self.hexRules["WithZeroX"] == 1 then
        self._checkForZeroX(hexVal)
        self._checkSize(hexVal.len-2,self.hexRules["Size"],sizeBaseErrorMessage+hexVal.len-2," ")
    else if self.hexRules["WithZeroX"] == 0 then
        self._checkSize(hexVal,self.hexRules["Size"],sizeBaseErrorMessage+hexVal," ")
    end if
end function

BaseNumericDataType._checkForZeroX = function(hexVal)
    hexVal = HexString.construct(hexVal).val
    return
end function
BaseNumericDataType._checkSize = function(toCheck,ToBe,message)
    checkStrictEqual(toCheck,ToBe,@exit,message)
end function
BaseNumericDataType.setDecVal = function(decVal)
    self._validateDecVal(decVal)
    self._decVal = decVal
end function


BaseNumericDataType.getDecVal = function()
    return self._decVal 
end function

BaseNumericDataType.setBinaryVal = function(binaryVal)
    self._validateBinaryVal(binaryVal)
    self._binaryVal= binaryVal
end function


BaseNumericDataType.getBinaryVal = function()
    return self._binaryVal 
end function


BaseNumericDataType.setHexVal = function(hexVal)
    self._validateHexVal(hexVal)
    self._hexVal = hexVal
end function


BaseNumericDataType.getHexVal = function()
    return self._hexVal 
end function
BaseNumericDataType._provideFullBinaryString = function()
    binaryVal = self.getBinaryVal()
    FullBinVal = ""
    for binVal in binaryVal
        FullBinVal = FullBinVal + binVal
    end for
    return FullBinVal
end function
BaseNumericDataType.computeDecValFromBinaryVal = function()
    FullBinVal = self._provideFullBinaryString
    if self.decRules["NegativeAllowed"] == 0 then
        deVal = BitToDecInBytes(FullBinVal,self.binaryRules["Bytessize"])
        self.setDecVal(deVal)
    else
        prefix = FullBinVal[0]
        if prefix == "1" then
            binVal = slice(FullBinVal,1,self.binaryRules["Bytessize"]*8)
            binVal = "0" + binVal
            decValWOPrefix = BitToDecInBytes(binVal,self.binaryRules["Bytessize"])
            if decValWOPrefix == 0 then
                self.setDecVal(pow(2,FullBinVal.len) * -1)
            end if
        end if
    end if
end function

BaseNumericDataType._binaryStringToBinaryArray = function(binaryString)
    binaryVal = []
    for i in range(0,(self.binaryRules["Bytessize"]-1))
        binaryVal.push(slice(binaryString,i*8,(i+1)*8-1))
    end for
    return binaryVal
end function
BaseNumericDataType.computeBinaryValFromDecVal = function()
    decVal = str(self.getDecVal())
    if slice(decVal,0,0) != "-" then
        binVal = DecToBinInBytes(decVal.val,self.binaryRules["Bytessize"])
        binVal = self._binaryStringToBinaryArray(binVal)
        self.setBinaryVal(binVal)
    else
        decVal = slice(decVal,1,decVal.len)
        binVal = DecToBinInBytes(decVal,self.binaryRules["Bytessize"])
        binVal = self._binaryStringToBinaryArray(binVal)
        switch = binVal[0]
        switch = "1"+slice(switch,1,7)
        self.setBinaryVal(binVal)
    end if
end function

    
BaseNumericDataType.computeHexValFromBinaryVal = function()
    binaryVal = self.getBinaryVal()
    FullBinVal = self._provideFullBinaryString()
    hexVal = BinToHexInBytes(FullBinVal,self.binaryRules["Bytessize"]).val
    if self.hexRules["WithZeroX"] == 0 then
        hexVal = slice(hexVal,2,self.hexRules["Size"])
    end if
    self.setHexVal(hexVal)
end function

BaseNumericDataType.computeBinaryValFromHexVal = function()
    hexVal = self.getHexVal
end function


UIntEight = new BaseNumericDataType.construct()
UIntEight.construct = function(arrayWithOneByte)
    if typeof(arrayWithOneByte) != "list" then
        return exit("arrayWithOneByte has to be of type list. Provided was: "+typeof(arrayWithOneByte)+".")
    end if
    if arrayWithOneByte.len != 1 then
        return exit("The provided array has to have a lenght of 1. Your had a length of: "+arrayWithOneByte.len+".")
    end if
    bitString = BitString.construct(arrayWithOneByte[0]).val
    if bitString.len != 8 then
        return exit("The provided lenght of the value in arrayWithOneByte[0] has to be 8. Yours had a lenght of"+bitString.len+"")
    end if
    dec = BitToDecInBytes(bitString,1)
    self.val = dec
    return self
end function

IntEight = {}
IntEight.construct = function(arrayWithOneByte)
    if typeof(arrayWithOneByte) != "list" then
        return exit("arrayWithOneByte has to be of type list. Provided was: "+typeof(arrayWithOneByte)+".")
    end if
    if arrayWithOneByte.len != 1 then
        return exit("The provided array has to have a lenght of 1. Your had a length of: "+arrayWithOneByte.len+".")
    end if
    binaryString = BitString.construct(arrayWithOneByte[0]).val
    if binaryString.len != 8 then
        return exit("The provided lenght of the value in arrayWithOneByte[0] has to be 8. Yours had a lenght of"+binaryString.len+"")
    end if 
    prefix = binaryString[0]
    binaryString = slice(binaryString,1,8)
    binaryString = "0" + binaryString
    decimalWithoutPrefix = BitToDecInBytes(binaryString,1)
    if prefix == "0" then
        self.val = decimalWithoutPrefix * 1
    else
        if prefix == "1" then
        self.val =  decimalWithoutPrefix * -1
        end if
    end if
    return self
end function

UIntSixTeen = {}
UIntSixTeen.construct = function(arrayBuffer)
    if typeof(arrayBuffer) != "list" then
        return exit("UIntSixTeen.construct: arrayBuffer has to be of type list. Provided was: "+typeof(arrayBuffer)+".")
    end if
    if arrayBuffer.len != 2 then
        return exit("UIntSixTeen.construct: arrayBuffer has to have a lenght of 2. Your had a length of: "+arrayBuffer.len+".")
    end if
    FirstBitString = BitString.construct(arrayBuffer[0]).val
    if FirstBitString.len != 8 then
        return exit("UIntSixTeen.construct: lenght of arrayBuffer[0] has to be 8. provided was a lenght of"+FirstBitString.len+"")
    end if
    SecondBitString = BitString.construct(arrayBuffer[1]).val
    if SecondBitString.len != 8 then
        return exit("UIntSixTeen.construct: lenght of arrayBuffer[1] has to be 8. provided was a lenght of"+SecondBitString.len+"")
    end if
    bitString = BitString.construct(FirstBitString+SecondBitString).val
    dec = BitToDecInBytes(bitString,2)
    self.val = dec
    return self
end function

IntSixTeen = {}
IntSixTeen.construct = function(arrayBuffer)
    if typeof(arrayBuffer) != "list" then
        return exit("IntSixTeen.construct: arrayBuffer has to be of type list. Provided was: "+typeof(arrayBuffer)+".")
    end if
    if arrayBuffer.len != 2 then
        return exit("IntSixTeen.construct: arrayBuffer has to have a lenght of 2. Your had a length of: "+arrayBuffer.len+".")
    end if
    FirstBitString = BitString.construct(arrayBuffer[0]).val
    if FirstBitString.len != 8 then
        return exit("IntSixTeen.construct: lenght of arrayBuffer[0] has to be 8. provided was a lenght of"+FirstBitString.len+"")
    end if
    SecondBitString = BitString.construct(arrayBuffer[1]).val
    if SecondBitString.len != 8 then
        return exit("IntSixTeen.construct: lenght of arrayBuffer[1] has to be 8. provided was a lenght of"+SecondBitString.len+"")
    end if
    prefix = FirstBitString[0]
    FirstBitString = slice(FirstBitString,1,8)  
    binaryString = "0" + FirstBitString + SecondBitString
    decimalWithoutPrefix = BitToDecInBytes(binaryString,2)
    if prefix == "0" then
        self.val = decimalWithoutPrefix * 1
    else
        if prefix == "1" then
        self.val =  decimalWithoutPrefix * -1
        end if
    end if
    return self
end function

UIntThirtyTwo = {}
UIntThirtyTwo.construct = function(arrayBuffer)
    if typeof(arrayBuffer) != "list" then
        return exit("UIntThirtyTwo.construct: arrayBuffer has to be of type list. Provided was: "+typeof(arrayBuffer)+".")
    end if
    if arrayBuffer.len != 2 then
        return exit("UIntThirtyTwo.construct: arrayBuffer has to have a lenght of 2. Your had a length of: "+arrayBuffer.len+".")
    end if
    FirstBitString = BitString.construct(arrayBuffer[0]).val
    if FirstBitString.len != 8 then
        return exit("UIntThirtyTwo.construct: lenght of arrayBuffer[0] has to be 8. provided was a lenght of"+FirstBitString.len+"")
    end if
    SecondBitString = BitString.construct(arrayBuffer[1]).val
    if SecondBitString.len != 8 then
        return exit("UIntThirtyTwo.construct: lenght of arrayBuffer[1] has to be 8. provided was a lenght of"+SecondBitString.len+"")
    end if
    ThirdBitString = BitString.construct(arrayBuffer[2]).val
    if ThirdBitString.len != 8 then
        return exit("UIntThirtyTwo.construct: lenght of arrayBuffer[2] has to be 8. provided was a lenght of"+ThirdBitString.len+"")
    end if
    FourthBitString = BitString.construct(arrayBuffer[3]).val
    if FourthBitString.len != 8 then
        return exit("UIntThirtyTwo.construct: lenght of arrayBuffer[3] has to be 8. provided was a lenght of"+FourthBitString.len+"")
    end if
    bitString = BitString.construct(FirstBitString+SecondBitString+ThirdBitString+FourthBitString).val
    dec = BitToDecInBytes(bitString,4)
    self.val = dec
    return self
end function

IntThirtyTwo = {}
IntThirtyTwo.construct = function(arrayBuffer)
    if typeof(arrayBuffer) != "list" then
        return exit("IntThirtyTwo.construct: arrayBuffer has to be of type list. Provided was: "+typeof(arrayBuffer)+".")
    end if
    if arrayBuffer.len != 2 then
        return exit("IntThirtyTwo.construct: arrayBuffer has to have a lenght of 2. Your had a length of: "+arrayBuffer.len+".")
    end if
    FirstBitString = BitString.construct(arrayBuffer[0]).val
    if FirstBitString.len != 8 then
        return exit("IntThirtyTwo.construct: lenght of arrayBuffer[0] has to be 8. provided was a lenght of"+FirstBitString.len+"")
    end if
    SecondBitString = BitString.construct(arrayBuffer[1]).val
    if SecondBitString.len != 8 then
        return exit("IntThirtyTwo.construct: lenght of arrayBuffer[1] has to be 8. provided was a lenght of"+SecondBitString.len+"")
    end if
    ThirdBitString = BitString.construct(arrayBuffer[2]).val
    if ThirdBitString.len != 8 then
        return exit("IntThirtyTwo.construct: lenght of arrayBuffer[2] has to be 8. provided was a lenght of"+ThirdBitString.len+"")
    end if
    FourthBitString = BitString.construct(arrayBuffer[3]).val
    if FourthBitString.len != 8 then
        return exit("IntThirtyTwo.construct: lenght of arrayBuffer[3] has to be 8. provided was a lenght of"+FourthBitString.len+"")
    end if
    prefix = FirstBitString[0]
    FirstBitString = slice(FirstBitString,1,8)  
    binaryString = "0" + FirstBitString + SecondBitString+ ThirdBitString + FourthBitString
    decimalWithoutPrefix = BitToDecInBytes(binaryString,2)
    if prefix == "0" then
        self.val = decimalWithoutPrefix * 1
    else
        if prefix == "1" then
        self.val =  decimalWithoutPrefix * -1
        end if
    end if
    return self
end function

UIntSixtyFour = {}
UIntSixtyFour.construct = function(arrayBuffer)
    if typeof(arrayBuffer) != "list" then
        return exit("UIntSixtyFour.construct: arrayBuffer has to be of type list. Provided was: "+typeof(arrayBuffer)+".")
    end if
    if arrayBuffer.len != 2 then
        return exit("UIntSixtyFour.construct: arrayBuffer has to have a lenght of 2. Your had a length of: "+arrayBuffer.len+".")
    end if
    FirstBitString = BitString.construct(arrayBuffer[0]).val
    if FirstBitString.len != 8 then
        return exit("UIntSixtyFour.construct: lenght of arrayBuffer[0] has to be 8. provided was a lenght of"+FirstBitString.len+"")
    end if
    SecondBitString = BitString.construct(arrayBuffer[1]).val
    if SecondBitString.len != 8 then
        return exit("UIntSixtyFour.construct: lenght of arrayBuffer[1] has to be 8. provided was a lenght of"+SecondBitString.len+"")
    end if
    ThirdBitString = BitString.construct(arrayBuffer[2]).val
    if ThirdBitString.len != 8 then
        return exit("UIntSixtyFour.construct: lenght of arrayBuffer[2] has to be 8. provided was a lenght of"+ThirdBitString.len+"")
    end if
    FourthBitString = BitString.construct(arrayBuffer[3]).val
    if FourthBitString.len != 8 then
        return exit("UIntSixtyFour.construct: lenght of arrayBuffer[3] has to be 8. provided was a lenght of"+FourthBitString.len+"")
    end if
    bitString = BitString.construct(FirstBitString+SecondBitString+ThirdBitString+FourthBitString).val
    dec = BitToDecInBytes(bitString,4)
    self.val = dec
    return self
end function

IntSixtyFour = {}
IntSixtyFour.construct = function(arrayBuffer)
    if typeof(arrayBuffer) != "list" then
        return exit("IntSixtyFour.construct: arrayBuffer has to be of type list. Provided was: "+typeof(arrayBuffer)+".")
    end if
    if arrayBuffer.len != 2 then
        return exit("IntSixtyFour.construct: arrayBuffer has to have a lenght of 2. Your had a length of: "+arrayBuffer.len+".")
    end if
    FirstBitString = BitString.construct(arrayBuffer[0]).val
    if FirstBitString.len != 8 then
        return exit("IntSixtyFour.construct: lenght of arrayBuffer[0] has to be 8. provided was a lenght of"+FirstBitString.len+"")
    end if
    SecondBitString = BitString.construct(arrayBuffer[1]).val
    if SecondBitString.len != 8 then
        return exit("IntSixtyFour.construct: lenght of arrayBuffer[1] has to be 8. provided was a lenght of"+SecondBitString.len+"")
    end if
    ThirdBitString = BitString.construct(arrayBuffer[2]).val
    if ThirdBitString.len != 8 then
        return exit("IntSixtyFour.construct: lenght of arrayBuffer[2] has to be 8. provided was a lenght of"+ThirdBitString.len+"")
    end if
    FourthBitString = BitString.construct(arrayBuffer[3]).val
    if FourthBitString.len != 8 then
        return exit("IntSixtyFour.construct: lenght of arrayBuffer[3] has to be 8. provided was a lenght of"+FourthBitString.len+"")
    end if
    FifthBitString = BitString.construct(arrayBuffer[3]).val
    if FifthBitString.len != 8 then
        return exit("IntSixtyFour.construct: lenght of arrayBuffer[3] has to be 8. provided was a lenght of"+FifthBitString.len+"")
    end if
    SixtBitString = BitString.construct(arrayBuffer[3]).val
    if SixtBitString.len != 8 then
        return exit("IntSixtyFour.construct: lenght of arrayBuffer[3] has to be 8. provided was a lenght of"+SixtBitString.len+"")
    end if
    SeventhBitString = BitString.construct(arrayBuffer[3]).val
    if SeventhBitString.len != 8 then
        return exit("IntSixtyFour.construct: lenght of arrayBuffer[3] has to be 8. provided was a lenght of"+SeventhBitString.len+"")
    end if
    EigthBitString = BitString.construct(arrayBuffer[3]).val
    if EigthBitString.len != 8 then
        return exit("IntSixtyFour.construct: lenght of arrayBuffer[3] has to be 8. provided was a lenght of"+EigthBitString.len+"")
    end if
    prefix = FirstBitString[0]
    FirstBitString = slice(FirstBitString,1,8)  
    binaryString = "0" + FirstBitString + SecondBitString+ ThirdBitString + FourthBitString + FifthBitString + SixtBitString + SeventhBitString + EigthBitString
    decimalWithoutPrefix = BitToDecInBytes(binaryString,2)
    if prefix == "0" then
        self.val = decimalWithoutPrefix * 1
    else
        if prefix == "1" then
        self.val =  decimalWithoutPrefix * -1
        end if
    end if
    return self
end function